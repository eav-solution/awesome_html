<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <title>Face Mesh - Center Stage (No Distortion)</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        .container {
            position: relative;
            width: 100%;
            max-width: 1280px;
            aspect-ratio: 16 / 9;
        }

        .input_video {
            display: none;
        }

        .output_canvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
            box-shadow: 0 0 30px cyan;
            /* Lật ngược canvas để tạo hiệu ứng gương tự nhiên */
            transform: scaleX(-1);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: cyan;
            font-family: monospace;
            font-size: 20px;
            animation: blink 1s infinite;
            z-index: 10;
        }

        @keyframes blink {
            50% {
                opacity: 0;
            }
        }
    </style>
</head>

<body>

    <div class="container">
        <div class="loading" id="loading-text">Đang tải Model...</div>
        <video class="input_video" autoplay playsinline></video>
        <canvas class="output_canvas"></canvas>
    </div>

    <script type="module">
        import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js";

        const video = document.querySelector('.input_video');
        const canvasElement = document.querySelector('.output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const loadingText = document.getElementById('loading-text');

        let faceLandmarker;
        let lastVideoTime = -1;
        let results = undefined;

        // --- CẤU HÌNH ---
        // 0.5 = Zoom 2x, 1.0 = Full frame
        const ZOOM_LEVEL = 0.6;
        const LERP_FACTOR = 0.1; // Độ mượt (càng nhỏ càng mượt)

        let currentCrop = { x: 0, y: 0, w: 1280, h: 720 };

        async function createFaceLandmarker() {
            const filesetResolver = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/wasm");
            faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                    delegate: "GPU"
                },
                outputFaceBlendshapes: false,
                runningMode: "VIDEO",
                numFaces: 1
            });
            loadingText.innerText = "Đang mở Camera...";
            enableCam();
        }

        function enableCam() {
            if (!faceLandmarker) return;
            navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } }).then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    // Khởi tạo khung hình đầu tiên full màn hình
                    currentCrop = { x: 0, y: 0, w: video.videoWidth, h: video.videoHeight };
                    predictWebcam();
                    loadingText.style.display = "none";
                });
            });
        }

        function lerp(start, end, factor) {
            return start + (end - start) * factor;
        }

        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        async function predictWebcam() {
            // Đồng bộ kích thước canvas với video
            if (canvasElement.width !== video.videoWidth) {
                canvasElement.width = video.videoWidth;
                canvasElement.height = video.videoHeight;
            }

            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                results = faceLandmarker.detectForVideo(video, performance.now());
            }

            // 1. Xác định kích thước vùng cắt (Luôn giữ tỉ lệ aspect ratio)
            // Logic: Chiều rộng crop = Chiều rộng video * ZOOM_LEVEL
            // Chiều cao crop = Chiều rộng crop / Tỉ lệ khung hình video
            const videoAspect = video.videoWidth / video.videoHeight;
            let targetW = video.videoWidth * ZOOM_LEVEL;
            let targetH = targetW / videoAspect;

            // 2. Xác định tâm điểm
            let centerX = video.videoWidth / 2;
            let centerY = video.videoHeight / 2;

            if (results && results.faceLandmarks.length > 0) {
                const landmarks = results.faceLandmarks[0];

                // Tìm biên của khuôn mặt
                const xs = landmarks.map(l => l.x);
                const ys = landmarks.map(l => l.y);
                // Tính tâm khuôn mặt (Pixel thực tế)
                centerX = ((Math.min(...xs) + Math.max(...xs)) / 2) * video.videoWidth;
                centerY = ((Math.min(...ys) + Math.max(...ys)) / 2) * video.videoHeight;
            }

            // 3. Tính toạ độ góc trên bên trái (Top-Left) của vùng cắt
            let targetX = centerX - (targetW / 2);
            let targetY = centerY - (targetH / 2);

            // 4. CLAMP: Giới hạn vùng cắt không được tràn ra ngoài video gốc
            // Điều này cực quan trọng để tránh hình bị kéo giãn
            targetX = clamp(targetX, 0, video.videoWidth - targetW);
            targetY = clamp(targetY, 0, video.videoHeight - targetH);

            // 5. Lerp để mượt chuyển động
            currentCrop.x = lerp(currentCrop.x, targetX, LERP_FACTOR);
            currentCrop.y = lerp(currentCrop.y, targetY, LERP_FACTOR);
            currentCrop.w = lerp(currentCrop.w, targetW, LERP_FACTOR);
            currentCrop.h = lerp(currentCrop.h, targetH, LERP_FACTOR);

            // 6. Vẽ
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            // Vẽ phần crop lên toàn bộ canvas
            // sx, sy, sw, sh: Vùng lấy từ video gốc
            // dx, dy, dw, dh: Vùng vẽ lên canvas (full canvas)
            canvasCtx.drawImage(
                video,
                currentCrop.x, currentCrop.y, currentCrop.w, currentCrop.h,
                0, 0, canvasElement.width, canvasElement.height
            );

            window.requestAnimationFrame(predictWebcam);
        }

        createFaceLandmarker();
    </script>
</body>

</html>
